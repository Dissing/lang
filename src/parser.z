struct ParsingContext {
  current_token: u64,
  tokens: *Token,
  num_tokens: u64,
  source_map: *SourceMap,
  sess: *Session,
  ast: *Ast,
  current_def: NodeId,
}

fn is_done_parsing(ctx: *ParsingContext) -> bool {
  return ctx.num_tokens == ctx.current_token;
}

fn accept(ctx: *ParsingContext, token: TokenKind) -> bool {
  var tok : Token = ctx.tokens[ctx.current_token];
  if !is_done_parsing(ctx) && tok.kind == token {
    ctx.current_token = ctx.current_token + 1;
    return true;
  }
  return false;
}

fn can_accept(ctx: *ParsingContext, token: TokenKind) -> bool {
  var tok : Token = ctx.tokens[ctx.current_token];
  if !is_done_parsing(ctx) && tok.kind == token {
    return true;
  }
  return false;
}

fn look_ahead(ctx: *ParsingContext, offset: u64) -> Token {
  if ctx.current_token == ctx.num_tokens {
    var eof_tok: Token;
    eof_tok.kind = EOF;
    return eof_tok;
  } else  return ctx.tokens[ctx.current_token + offset];
}

fn consume(ctx: *ParsingContext) -> Token {
  ctx.current_token = ctx.current_token + 1;
  return ctx.tokens[ctx.current_token - 1];
}

fn expect(ctx: *ParsingContext, kind: TokenKind) -> Token {
  var tok: Token = consume(ctx);
  if tok.kind == kind {
    return tok;
  } else {
    emit_error(ctx.source_map, tok.span, "Expect failed!");
    abort();
  }
}

fn span_start(ctx: *ParsingContext) -> u32 {
  return ctx.tokens[ctx.current_token].span.from;
}

fn span_end(ctx: *ParsingContext) -> u32 {
  return ctx.tokens[ctx.current_token - 1].span.to;
}

fn parse_identifier(ctx: *ParsingContext) -> Ident {

  var tok: Token = consume(ctx);

  if tok.kind != TokenKind::Identifier  emit_error(ctx.source_map, tok.span, "Invalid identifier");

  var ident: Ident;
  ident.name = tok.lexeme;
  return ident;
}

fn parse_path(ctx: *ParsingContext) -> Path {
  var path: Path;
  path.segments = malloc(8 * 4);
  path.num_segments = 0;
  path.span.from = span_start(ctx);

  while true {
    path.segments[path.num_segments] = parse_identifier(ctx);
    path.num_segments = path.num_segments + 1;
    if !accept(ctx, TokenKind::ColonColon)  break;
  }

  path.span.to = span_end(ctx);
  return path;
}

fn parse_path_expr(ctx: *ParsingContext) -> *Expr {
  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Path);
  expr.node.path = parse_path(ctx);
  return expr;
}

fn parse_type(ctx: *ParsingContext) -> *AstType {
  var node: AstTypeKindNode;
  var kind: AstTypeKind;

  val token: Token = consume(ctx);
  if token.kind == TokenKind::Identifier {
    kind = AstTypeKind::Path;
    node.path = token.lexeme; //parse_path(ctx, token);
  } else if token.kind == TokenKind::Star {
    kind = AstTypeKind::Ptr;
    node.ptr = parse_type(ctx);
  } else if token.kind == TokenKind::Ellipsis {
    kind = AstTypeKind::Variadic;
  }
  else  emit_error(ctx.source_map, token.span, "Expected type");

  var type: *AstType = malloc(sizeof(AstType));
  type.kind = kind;
  type.node = node;

  return type;
}

fn convert_token_to_binary_operator(tok: TokenKind) -> BinaryOperatorKind {
  if tok == TokenKind::Plus  return BinaryOperatorKind::Addition;
  else if tok == TokenKind::Minus  return BinaryOperatorKind::Subtraction;
  else if tok == TokenKind::Star  return BinaryOperatorKind::Product;
  else if tok == TokenKind::Slash  return BinaryOperatorKind::Division;
  else if tok == TokenKind::Percent  return BinaryOperatorKind::Modulus;
  else if tok == TokenKind::Less  return BinaryOperatorKind::Less;
  else if tok == TokenKind::LessEqual  return BinaryOperatorKind::LessEq;
  else if tok == TokenKind::Greater  return BinaryOperatorKind::Greater;
  else if tok == TokenKind::GreaterEqual  return BinaryOperatorKind::GreaterEq;
  else if tok == TokenKind::EqualEqual  return BinaryOperatorKind::Equality;
  else if tok == TokenKind::BangEqual  return BinaryOperatorKind::NotEq;
  else if tok == TokenKind::AndAnd  return BinaryOperatorKind::And;
  else if tok == TokenKind::OrOr  return BinaryOperatorKind::Or;
  else if tok == TokenKind::And  return BinaryOperatorKind::BAnd;
  else if tok == TokenKind::Or  return BinaryOperatorKind::BOr;
  else if tok == TokenKind::Hat  return BinaryOperatorKind::Xor;
  else if tok == TokenKind::LessLess  return BinaryOperatorKind::LeftShift;
  else if tok == TokenKind::GreaterGreater  return BinaryOperatorKind::RightShift;
  else  return BinaryOperatorKind::Invalid;
}

fn get_binary_operator_precedence(op: BinaryOperatorKind) -> u32 {
  if op == BinaryOperatorKind::Product  return 10;
  else if op == BinaryOperatorKind::Division  return 10;
  else if op == BinaryOperatorKind::Modulus  return 10;
  else if op == BinaryOperatorKind::Addition  return 9;
  else if op == BinaryOperatorKind::Subtraction  return 9;
  else if op == BinaryOperatorKind::LeftShift  return 8;
  else if op == BinaryOperatorKind::RightShift  return 8;
  else if op == BinaryOperatorKind::BAnd  return 7;
  else if op == BinaryOperatorKind::Xor  return 6;
  else if op == BinaryOperatorKind::BOr  return 5;
  else if op == BinaryOperatorKind::Less  return 4;
  else if op == BinaryOperatorKind::LessEq  return 4;
  else if op == BinaryOperatorKind::Greater  return 4;
  else if op == BinaryOperatorKind::GreaterEq  return 4;
  else if op == BinaryOperatorKind::Equality  return 4;
  else if op == BinaryOperatorKind::NotEq  return 4;
  else if op == BinaryOperatorKind::And  return 3;
  else if op == BinaryOperatorKind::Or  return 2;
  else return 0;
}

fn get_current_precedence(ctx: *ParsingContext) -> u32 {

  if ctx.num_tokens <= ctx.current_token {
    return 0;
  } else {
    var tok : Token = ctx.tokens[ctx.current_token];
    var op_precedence: u32 = get_binary_operator_precedence(convert_token_to_binary_operator(tok.kind));
    if op_precedence > 0  return op_precedence;
    else if tok.kind == TokenKind::Dot  return 13;
    else if (tok.kind == TokenKind::LeftBracket || tok.kind == TokenKind::LeftParen)  return 12;
    else  return 0;
  }
}

fn parse_expression(ctx: *ParsingContext, precedence: u32) -> *Expr

fn parse_integer_literal(ctx: *ParsingContext) -> *Expr {

  var tok: Token = expect(ctx, TokenKind::Integer);

  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Literal);
  expr.node.lit.kind = LiteralKind::Int;

  var sess: *Session = ctx.sess;
  expr.node.lit.value.integer = atol(get_str(&sess.interner, tok.lexeme));
  return expr;
}

fn parse_float_literal(ctx: *ParsingContext) -> *Expr {

  var tok: Token = expect(ctx, TokenKind::Float);

  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Literal);
  expr.node.lit.kind = LiteralKind::Float;

  var sess: *Session = ctx.sess;
  expr.node.lit.value.floating = atof(get_str(&sess.interner, tok.lexeme));
  return expr;
}

fn parse_char_literal(ctx: *ParsingContext) -> *Expr {

  var tok: Token = expect(ctx, TokenKind::Char);

  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Literal);
  expr.node.lit.kind = LiteralKind::Char;

  var sess: *Session = ctx.sess;
  var s: *char = get_str(&sess.interner, tok.lexeme);

  val len: u32 = strlen(s);
  if len == 2 && s[0] == '\\' {
    var c: char;
    if s[1] == 'n'  c = '\n';
    else if s[1] == 't'  c = '\t';
    else if s[1] == 'r'  c = '\r';
    else if s[1] == '\\'  c = '\\';
    else if s[1] == '\''  c = '\'';
    else  emit_error(ctx.source_map, tok.span, "Unknown escape sequence");
    expr.node.lit.value.ch = c;
  } else if len == 1 {
    expr.node.lit.value.ch = s[0];
  }
  else  emit_error(ctx.source_map, tok.span, "Invalid char literal");

  return expr;
}

fn parse_string_literal(ctx: *ParsingContext) -> *Expr {

  var tok: Token = expect(ctx, TokenKind::String);

  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Literal);
  expr.node.lit.kind = LiteralKind::Str;

  expr.node.lit.value.str = tok.lexeme;
  return expr;
}

fn parse_bool_literal(ctx: *ParsingContext) -> *Expr {

  var tok: Token = consume(ctx);

  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Literal);
  expr.node.lit.kind = LiteralKind::Bool;
  expr.node.lit.value.boolean = tok.kind == TokenKind::True;
  return expr;
}

fn parse_call(ctx: *ParsingContext, left: *Expr) -> *Expr {

  var result: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Call);
  result.node.call.func = left;
  result.node.call.args = malloc(8 * 16);
  result.node.call.num_args = 0;

  if !accept(ctx, TokenKind::RightParen) {
    while true {
      var expr: *Expr = parse_expression(ctx, 0);
      result.node.call.args[result.node.call.num_args] = expr;
      result.node.call.num_args = result.node.call.num_args + 1;
      if !accept(ctx, TokenKind::Comma)  break;
    }
    expect(ctx, TokenKind::RightParen);
  }

  return result;

}

fn parse_prefix_operator(ctx: *ParsingContext) -> *Expr {
  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Unary);

  var tok: Token = consume(ctx);

  if tok.kind == TokenKind::Minus  expr.node.unary.op = UnaryOperatorKind::Negation;
  else if tok.kind == TokenKind::Bang  expr.node.unary.op = UnaryOperatorKind::Complement;
  else if tok.kind == TokenKind::And  expr.node.unary.op = UnaryOperatorKind::Refer;
  else if tok.kind == TokenKind::Star  expr.node.unary.op = UnaryOperatorKind::Deref;
  else  emit_error(ctx.source_map, tok.span, "Invalid prefix operator");

  expr.node.unary.inner = parse_expression(ctx, 11);

  return expr;
}

fn parse_binary_operator(ctx: *ParsingContext, left: *Expr, operator: BinaryOperatorKind) -> *Expr {
  val precedence: u32 = get_binary_operator_precedence(operator);
  val right: *Expr = parse_expression(ctx, precedence);

  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Binary);
  expr.node.binary.op = operator;
  expr.node.binary.left = left;
  expr.node.binary.right = right;

  return expr;
}

fn parse_field_access(ctx: *ParsingContext, left: *Expr) -> *Expr {
  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Field);
  expr.node.field.ident = parse_identifier(ctx);
  expr.node.field.strct = left;

  return expr;
}

fn parse_indexing(ctx: *ParsingContext, left: *Expr) -> *Expr {

  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Indexing);
  expr.node.indexing.index = parse_expression(ctx, 0);
  expr.node.indexing.array = left;

  expect(ctx, TokenKind::RightBracket);

  return expr;
}

fn parse_infix_operator(ctx: *ParsingContext, left: *Expr, tok: Token) -> *Expr {

  if tok.kind == TokenKind::LeftParen  return parse_call(ctx, left);
  if tok.kind == TokenKind::Dot  return parse_field_access(ctx, left);
  if tok.kind == TokenKind::LeftBracket  return parse_indexing(ctx, left);

  val op: BinaryOperatorKind = convert_token_to_binary_operator(tok.kind);
  if op != BinaryOperatorKind::Invalid {
    return parse_binary_operator(ctx, left, op);
  }
  else  emit_error(ctx.source_map, tok.span, "Unsupported infix operator");
  return null;
}

fn parse_stmt(ctx: *ParsingContext) -> *Stmt
fn parse_block(ctx: *ParsingContext) -> *Block {

  var block : *Block = malloc(sizeof(Block));
  block.stmts = malloc(8 * 128);
  block.num_stmts = 0;
  block.span.from = span_start(ctx);

  val next : Token = look_ahead(ctx, 0);
  if next.kind == TokenKind::LeftCurly {
    expect(ctx, TokenKind::LeftCurly);
    var i: u32 = 0;
    while !accept(ctx, TokenKind::RightCurly) {
      block.stmts[i] = parse_stmt(ctx);
      block.num_stmts = block.num_stmts + 1;
      i = i + 1;
    }
  } else {
    block.stmts[0] = parse_stmt(ctx);
    block.num_stmts = 1;
  }
  block.span.to = span_end(ctx);

  return block;
}

fn parse_block_expr(ctx: *ParsingContext) -> *Expr {
  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Block);
  expr.node.block = parse_block(ctx);
  return expr;
}

fn parse_if(ctx: *ParsingContext) -> *Expr {

  expect(ctx, TokenKind::If);

  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::Conditional);
  expr.node.conditional.condition = parse_expression(ctx, 0);
  expr.node.conditional.then = parse_block_expr(ctx);

  if accept(ctx, TokenKind::Else) {
    expr.node.conditional.otherwise = parse_block_expr(ctx);
  } else {
    expr.node.conditional.otherwise = null;
  }

  return expr;
}

fn parse_while(ctx: *ParsingContext) -> *Expr {
  expect(ctx, TokenKind::While);

  var expr: *Expr = ast_create_expr(ctx.ast, ctx.current_def, ExprKind::While);
  expr.node.whl.condition = parse_expression(ctx, 0);
  expr.node.whl.body = parse_block_expr(ctx);

  return expr;
}

fn parse_expression(ctx: *ParsingContext, precedence: u32) -> *Expr {
  val tok: Token = look_ahead(ctx, 0);
  var span: Span;
  span.from = span_start(ctx);

  var left : *Expr;

  if tok.kind == TokenKind::Identifier  left = parse_path_expr(ctx);
  else if tok.kind == TokenKind::Integer  left = parse_integer_literal(ctx);
  else if tok.kind == TokenKind::Char  left = parse_char_literal(ctx);
  else if tok.kind == TokenKind::String  left = parse_string_literal(ctx);
  else if tok.kind == TokenKind::Float  left = parse_float_literal(ctx);
  else if (tok.kind == TokenKind::False || tok.kind == TokenKind::True)  left = parse_bool_literal(ctx);
  else if (tok.kind == TokenKind::Minus || tok.kind == TokenKind::Bang ||
           tok.kind == TokenKind::And || tok.kind == TokenKind::Star) left = parse_prefix_operator(ctx);
  else if tok.kind == TokenKind::If  left = parse_if(ctx);
  else if tok.kind == TokenKind::While  left = parse_while(ctx);
  else if tok.kind == TokenKind::LeftParen {
    expect(ctx, TokenKind::LeftParen);
    left = parse_expression(ctx, 0);
    expect(ctx, TokenKind::RightParen);
  }
  else if tok.kind == TokenKind::LeftCurly  left = parse_block_expr(ctx);
  else  emit_error(ctx.source_map, tok.span, "Invalid expression prefix");

  while precedence < get_current_precedence(ctx) {
    val next_tok : Token = consume(ctx);
    left = parse_infix_operator(ctx, left, next_tok);
  }
  span.to = span_end(ctx);
  left.span = span;

  return left;
}

fn parse_item(ctx: *ParsingContext) -> NodeId

fn parse_stmt(ctx: *ParsingContext) -> *Stmt {

  var stmt: *Stmt = ast_create_stmt(ctx.ast, ctx.current_def);
  stmt.span.from = span_start(ctx);

  val tok: Token = look_ahead(ctx, 0);
  if accept(ctx, TokenKind::Break) {
    stmt.kind = StmtKind::Break;
  } else if accept(ctx, TokenKind::Continue) {
    stmt.kind = StmtKind::Continue;
  } else if accept(ctx, TokenKind::Return) {
    stmt.kind = StmtKind::Return;
    stmt.node._return = parse_expression(ctx, 0);
  } else if accept(ctx, TokenKind::Defer) {
    stmt.kind = StmtKind::Defer;
    stmt.node._defer = parse_expression(ctx, 0);
  } else if accept(ctx, TokenKind::Semicolon) {
    stmt.kind = StmtKind::Empty;
  } else if (tok.kind == TokenKind::Var || tok.kind == TokenKind::Val) {
    stmt.kind = StmtKind::Item;
    stmt.node.item = parse_item(ctx);
  } else {
    val left: *Expr = parse_expression(ctx, 0);
    val next: Token = look_ahead(ctx, 0);

    if next.kind == TokenKind::Equal {
      stmt.kind = StmtKind::Assignment;
      stmt.node.assignment.left = left;
      expect(ctx, TokenKind::Equal);
      stmt.node.assignment.right = parse_expression(ctx, 0);
    } else {
      stmt.kind = StmtKind::Expr;
      stmt.node.expr = left;
    }
  }

  accept(ctx, TokenKind::Semicolon);
  stmt.span.to = span_end(ctx);

  return stmt;
}

fn parse_generics(ctx: *ParsingContext) -> Generics {
  expect(ctx, TokenKind::Less);
  var generics: Generics;
  generics.parameters = malloc(4 * sizeof(GenericParam));
  generics.num_parameters = 0;

  while !accept(ctx, TokenKind::Greater) {
    generics.parameters[generics.num_parameters].ident = parse_identifier(ctx);

    accept(ctx, TokenKind::Comma);
    generics.num_parameters = generics.num_parameters + 1;
  }
  return generics;
}

fn parse_body(ctx: *ParsingContext, def: NodeId) -> NodeId {
  return ast_create_body(ctx.ast, parse_expression(ctx, 0));
}

fn parse_variable_decl(ctx: *ParsingContext, item: *Item) {

  val keyword: Token = consume(ctx);
  if keyword.kind == TokenKind::Val  item.kind = ItemKind::Const;
  else if keyword.kind == TokenKind::Var  item.kind = ItemKind::Variable;
  else abort();

  item.ident = parse_identifier(ctx);
  expect(ctx, TokenKind::Colon);
  item.node.variable.ty = parse_type(ctx);

  if accept(ctx, TokenKind::Equal)  item.node.variable.body = parse_body(ctx, item.id);
  else  item.node.variable.body.def = 0;
}

fn parse_compound_decl(ctx: *ParsingContext, item: *Item) {

  if accept(ctx, TokenKind::Struct)  item.kind = ItemKind::Struct;
  else if accept(ctx, TokenKind::Union)  item.kind = ItemKind::Union;
  else abort();

  item.ident = parse_identifier(ctx);

  if can_accept(ctx, TokenKind::Less)  item.node.compound.generics = parse_generics(ctx);
  else  item.node.compound.generics.num_parameters = 0;

  expect(ctx, TokenKind::LeftCurly);

  item.node.compound.fields = malloc(sizeof(CompoundField) * 16);
  item.node.compound.num_fields = 0;

  while !accept(ctx, TokenKind::RightCurly) {
    val token: Token = consume(ctx);
    if token.kind != TokenKind::Identifier  emit_error(ctx.source_map, token.span, "Expected field identifier");

    item.node.compound.fields[item.node.compound.num_fields].ident.name = token.lexeme;
    expect(ctx, TokenKind::Colon);

    val type: *AstType = parse_type(ctx);
    item.node.compound.fields[item.node.compound.num_fields].ty = type;
    item.node.compound.num_fields = item.node.compound.num_fields + 1;
    expect(ctx, TokenKind::Comma);
  }
}


fn parse_enum_decl(ctx: *ParsingContext, item: *Item) {

  expect(ctx, TokenKind::Enum);
  item.kind = ItemKind::Enum;

  item.ident = parse_identifier(ctx);

  expect(ctx, TokenKind::LeftCurly);

  item.node._enum.variants = malloc(sizeof(EnumVariant) * 128);
  item.node._enum.num_variants = 0;

  while !accept(ctx, TokenKind::RightCurly) {
    item.node._enum.variants[item.node._enum.num_variants].ident = parse_identifier(ctx);
    item.node._enum.num_variants = item.node._enum.num_variants + 1;
    expect(ctx, TokenKind::Comma);
  }
}

fn parse_function_header(ctx: *ParsingContext) -> FunctionHeader {
  var header: FunctionHeader;

  header.parameters = malloc(sizeof(FunctionParameter) * 16);
  header.num_parameters = 0;

  if can_accept(ctx, TokenKind::Less)  header.generics = parse_generics(ctx);
  else  header.generics.num_parameters = 0;

  expect(ctx, TokenKind::LeftParen);

  while !accept(ctx, TokenKind::RightParen) {

    header.parameters[header.num_parameters].ident = parse_identifier(ctx);

    expect(ctx, TokenKind::Colon);
    val type: *AstType = parse_type(ctx);
    header.parameters[header.num_parameters].ty = type;
    header.parameters[header.num_parameters].id = ast_create_node_id(ctx.ast, ctx.current_def);
    header.num_parameters = header.num_parameters + 1;

    accept(ctx, TokenKind::Comma);
  }

  if accept(ctx, TokenKind::Arrow)  header.output = parse_type(ctx);
  else {
    //TODO Cleanup when proper field access has been implemented
    var output: *AstType = malloc(sizeof(AstType));
    output.kind = AstTypeKind::Void;
    header.output = output;
  }

  return header;
}

fn parse_function_decl(ctx: *ParsingContext, item: *Item) {
  expect(ctx, TokenKind::Fn);

  item.ident = parse_identifier(ctx);
  item.kind = ItemKind::Function;

  item.node.function.header = parse_function_header(ctx);

  if look_ahead(ctx, 0).kind == TokenKind::LeftCurly  item.node.function.body = parse_body(ctx, item.id);
  else  item.node.function.body.def = 0;
}

fn parse_use(ctx: *ParsingContext, item: *Item) {
  expect(ctx, TokenKind::Use);

  item.kind = ItemKind::Use;
  item.node._use.path = parse_path(ctx);

  accept(ctx, TokenKind::Semicolon);
}

fn parse_mod_inner(ctx: *ParsingContext) -> Mod
fn parse_mod_external(sess: *Session, ast: *Ast, path: *char) -> Mod

fn parse_mod(ctx: *ParsingContext, item: *Item) {
  expect(ctx, TokenKind::Mod);

  item.ident = parse_identifier(ctx);
  item.kind = ItemKind::Mod;

  if accept(ctx, TokenKind::LeftCurly)  item.node.module = parse_mod_inner(ctx);
  else {
    var sess: *Session = ctx.sess;
    var path: *char = get_str(&sess.interner, item.ident.name);
    item.node.module = parse_mod_external(ctx.sess, ctx.ast, path);
  }
}


fn parse_item(ctx: *ParsingContext) -> NodeId {
  val tok : Token = look_ahead(ctx, 0);

  var item: *Item = ast_create_item(ctx.ast);
  ctx.current_def = item.id;
  item.span.from = span_start(ctx);

  if tok.kind == TokenKind::Fn  parse_function_decl(ctx, item);
  else if tok.kind == TokenKind::Struct || tok.kind == TokenKind::Union  parse_compound_decl(ctx, item);
  else if tok.kind == TokenKind::Enum  parse_enum_decl(ctx, item);
  else if tok.kind == TokenKind::Var  || tok.kind == TokenKind::Val  parse_variable_decl(ctx, item);
  else if tok.kind == TokenKind::Use  parse_use(ctx, item);
  else if tok.kind == TokenKind::Mod  parse_mod(ctx, item);
  else  emit_error(ctx.source_map, tok.span, "Unexpected token on top-level");

  accept(ctx, TokenKind::Semicolon);

  item.span.to = span_end(ctx);
  return item.id;
}

fn parse_mod_inner(ctx: *ParsingContext) -> Mod {
  var module: Mod;
  module.span.from = span_start(ctx);
  module.items = malloc(sizeof(NodeId) * 2048);
  module.num_items = 0;

  while !accept(ctx, TokenKind::RightCurly) && !is_done_parsing(ctx) {
    module.items[module.num_items] = parse_item(ctx);
    module.num_items = module.num_items + 1;
  }

  module.span.to = span_end(ctx);

  return module;
}

fn parse_mod_external(sess: *Session, ast: *Ast, path: *char) -> Mod {

  var source_file: *SourceFile = source_map_new_file(&sess.source, sess.root_path, path);

  var tokens: *Token;
  var num_tokens: u32;
  lex(sess, source_file, &tokens, &num_tokens);

  val ctx: ParsingContext;
  ctx.current_token = 0;
  ctx.tokens = tokens;
  ctx.num_tokens = num_tokens;
  ctx.source_map = &sess.source;
  ctx.sess = sess;
  ctx.ast = ast;

  var module: Mod = parse_mod_inner(&ctx);

  return module;
}

fn parse(sess: *Session, root_module_name: *char) -> Ast {

  var ast: Ast;

  ast.body_map = intmap_create(2048);
  ast.bodies = malloc(sizeof(Body) * 2048);
  ast.num_bodies = 1; //Reserve zero idx for null body

  ast.items = malloc(sizeof(Item) * 2048);
  ast.num_items = 1; //Reserve zero idx for null item
  ast.next_local = calloc(sizeof(u32), 2048);

  ast.root_module = parse_mod_external(sess, &ast, root_module_name);

  return ast;
}
