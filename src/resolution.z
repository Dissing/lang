struct VariableInfo {
  ident: Ident,
  slot: u32,
}

struct VariableBlock {
  variables: *VariableInfo,
  num_variables: u32,
}

enum ScopeKind {
  VariableBlock,
  Module,
}

union ScopeNode {
  module: *Module,
  variable: VariableBlock,
}

struct Scope {
  kind: ScopeKind,
  node: ScopeNode,
}

struct PrimitiveTypeSids {
  _void: Sid,
  _bool: Sid,
  _char: Sid,
  _i8: Sid,
  _i16: Sid,
  _i32: Sid,
  _i64: Sid,
  _u8: Sid,
  _u16: Sid,
  _u32: Sid,
  _u64: Sid,
  _f32: Sid,
  _f64: Sid,
}

fn setup_primitive_ty_sids(i: *Interner, p: *PrimitiveTypeSids) {
  p._void = intern(i, "void");
  p._bool = intern(i, "bool");
  p._char = intern(i, "char");
  p._i8 = intern(i, "i8");
  p._i16 = intern(i, "i16");
  p._i32 = intern(i, "i32");
  p._i64 = intern(i, "i64");
  p._u8 = intern(i, "u8");
  p._u16 = intern(i, "u16");
  p._u32 = intern(i, "u32");
  p._u64 = intern(i, "u64");
  p._f32 = intern(i, "f32");
  p._f64 = intern(i, "f64");
}

struct ResolutionContext {
  scope_stack: *Scope,
  stack_top: u32,
  ast: *Ast,
  source_map: *SourceMap,
  interner: *Interner,
  root_module: *Module,
  primitive_ty_sids: PrimitiveTypeSids,
}

fn push_block(ctx: *ResolutionContext) {
  ctx.stack_top = ctx.stack_top + 1;
  var scope: *Scope = &ctx.scope_stack[ctx.stack_top];

  scope.kind = ScopeKind::VariableBlock;
  scope.node.variable.variables = malloc(8*32);
  scope.node.variable.num_variables = 0;
}

fn pop_block(ctx: *ResolutionContext) {
  var scope: *Scope = &ctx.scope_stack[ctx.stack_top];
  free(scope.node.variable.variables);
  ctx.stack_top = ctx.stack_top - 1;
}

fn push_variable(ctx: *ResolutionContext, ident: Ident) -> u32 {
  var scope: *Scope = &ctx.scope_stack[ctx.stack_top];
  if scope.kind != ScopeKind::VariableBlock  abort();
  var v: *VariableBlock = &scope.node.variable;
  v.variables[v.num_variables].ident = ident;
  v.variables[v.num_variables].slot = v.num_variables;
  v.num_variables = v.num_variables + 1;
  return v.variables[v.num_variables].slot;
}

fn push_module(ctx: *ResolutionContext, module: *Module) {
  ctx.stack_top = ctx.stack_top + 1;
  var scope: *Scope = &ctx.scope_stack[ctx.stack_top];

  scope.kind = ScopeKind::Module;
  scope.node.module = module;
}

fn pop_module(ctx: *ResolutionContext) {
  ctx.stack_top = ctx.stack_top - 1;
}



fn lookup(ctx: *ResolutionContext, ident: Ident) -> Path {
  var i: i32 = ctx.stack_top;
  while i > 0 {
    var scope: *Scope = &ctx.scope_stack[i];
    if scope.kind == ScopeKind::Module {
      var module: *Module = scope.node.module;
      var idx: u32 = intmap_lookup(module.index_lookup, ident.name.x)
      if idx > 0 {
        var entry: IndexEntry = module.index[idx];
        return entry.path;
      }
    }
    else if scope.kind == ScopeKind::VariableBlock {
      var block: *VariableBlock = &scope.node.variable;
      var j: i32 = block.num_variables - 1;
      while j >= 0 {
        var variable: VariableInfo = block.variables[j];
        if variable.ident.name.x == ident.name.x {
            val path: Path;
            path.segments = malloc(sizeof(Ident));
            path.segments[0] = variable.ident;
            path.num_segments = 1;
            path.binding.kind = BindingKind::Variable;
            path.binding.node.slot = variable.slot;
            return path;
        }
        j = j - 1;
      }
    }
    i = i - 1;
  }
  emit_error(ctx.source_map, ident.span, "Unable to resolve item");
  abort();
}

fn index_use_binding(ctx: *ResolutionContext, path: Path) -> Binding {
  var cur_mod: *Module = ctx.root_module;
  var i: u32 = 0;
  while true {
    var j: u32 = 0;
    var found: bool = false;
    while j < cur_mod.num_items {
      var item: *Item = cur_mod.items[j];
      if item.ident.name.x == path.segments[i].name.x  {
        if item.kind == ItemKind::Module {
          cur_mod = item.node.module;
        }
        else if i != path.num_segments - 1  emit_error(ctx.source_map, path.span, "Invalid path in use");

        if i == path.num_segments - 1  {
          var binding: Binding;
          binding.kind = BindingKind::Item;
          binding.node.item = item;
          return binding;
        }

        found = true;
      }
      j = j + 1;
    }
    if !found  emit_error(ctx.source_map, path.span, "Unable to resolve use");
    i = i + 1;
  }
}

fn absolute_use(ctx: *ResolutionContext, module: *Module, item: *Item) {
  var p: *Path = &item.node._use;
  var abs: Path;
  if p.segments[0].name.x == intern(ctx.interner, "self").x {
    abs.num_segments = module.path.num_segments + p.num_segments - 1;
    abs.segments = malloc(sizeof(Ident) * abs.num_segments);
    memcpy(abs.segments, module.path.segments, sizeof(Ident) * module.path.num_segments);
    memcpy(&abs.segments[module.path.num_segments], &p.segments[1], sizeof(Ident) * (p.num_segments - 1));
    *p = abs;
  }
  else if p.segments[0].name.x == intern(ctx.interner, "super").x {
    //module.parent.path + p[1..]
    var parent: *Module = module.parent;
    abs.num_segments = parent.path.num_segments + p.num_segments - 1;
    abs.segments = malloc(sizeof(Ident) * abs.num_segments);
    memcpy(abs.segments, parent.path.segments, sizeof(Ident) * parent.path.num_segments);
    memcpy(&abs.segments[parent.path.num_segments], &p.segments[1], sizeof(Ident) * (p.num_segments - 1));
    *p = abs;
  }
}

fn index_use(ctx: *ResolutionContext, module: *Module) {
  var i: u32 = 0;
  while i < module.num_items {
    var item: *Item = module.items[i];
    if item.kind == ItemKind::Use {
      absolute_use(ctx, module, item);
      var path: *Path = &item.node._use;
      if !path.segments[path.num_segments-1].name.x != 0 {
        abort(); //TODO
      } else {
        path.binding = index_use_binding(ctx, *path);
      }
    }

    if item.kind == ItemKind::Module {
        index_use(ctx, item.node.module);
    }

    i = i + 1;
  }
}

fn add_item(ctx: *ResolutionContext, module: *Module, item: *Item) {

  var idx_entry: *IndexEntry = &module.index[module.num_indices];

  idx_entry.path.num_segments = (module.path.num_segments + 1);
  idx_entry.path.segments = malloc(sizeof(Ident) * idx_entry.path.num_segments);
  memcpy(idx_entry.path.segments, module.path.segments, sizeof(Ident) * module.path.num_segments);
  idx_entry.path.segments[module.path.num_segments] = item.ident;
  idx_entry.path.binding.kind = BindingKind::Item;
  idx_entry.path.binding.node.item = item;

  intmap_insert(module.index_lookup, item.ident.name.x, module.num_indices);

  module.num_indices = module.num_indices + 1;
}

fn index_module(ctx: *ResolutionContext, module: *Module) {
  var i: u32 = 0;
  while i < module.num_items {
    var item: *Item = module.items[i];

    if item.kind == ItemKind::Use {
      var path: Path = item.node._use;

      if path.segments[path.num_segments-1].name.x != 0 {
        add_item(ctx, module, path.binding.node.item);
      } else {
      }
    } else {
      add_item(ctx, module, item);
    }
    i = i + 1;
  }

  i = 0;
  while i < module.num_items {
    var item: *Item = module.items[i];
    if item.kind == ItemKind::Module  index_module(ctx, item.node.module);
    i = i + 1;
  }
}

fn index_module_wildcard(ctx: *ResolutionContext, module: *Module) {
  var i: u32 = 0;
  while i < module.num_items {
    var item: *Item = module.items[i];

    if item.kind == ItemKind::Use {
      var path: Path = item.node._use;
      if !path.segments[path.num_segments-1].name.x == 0 {

      }
    }
    i = i + 1;
  }
}

fn check_if_sid_is_primitive(ctx: *ResolutionContext, s: Sid, prim: *PrimitiveTy) -> bool {

  val p: *PrimitiveTypeSids = &ctx.primitive_ty_sids;
  if s.x == p._void.x  prim.kind = PrimitiveTyKind::Void;
  else if s.x == p._bool.x  prim.kind = PrimitiveTyKind::Bool;
  else if s.x == p._char.x  prim.kind = PrimitiveTyKind::Char;

  else if s.x == p._i8.x { prim.kind = PrimitiveTyKind::Signed; prim.node.integer = IntegerSize::I8; }
  else if s.x == p._i16.x { prim.kind = PrimitiveTyKind::Signed; prim.node.integer = IntegerSize::I16; }
  else if s.x == p._i32.x { prim.kind = PrimitiveTyKind::Signed; prim.node.integer = IntegerSize::I32; }
  else if s.x == p._i64.x { prim.kind = PrimitiveTyKind::Signed; prim.node.integer = IntegerSize::I64; }

  else if s.x == p._u8.x { prim.kind = PrimitiveTyKind::Unsigned; prim.node.integer = IntegerSize::I8; }
  else if s.x == p._u16.x { prim.kind = PrimitiveTyKind::Unsigned; prim.node.integer = IntegerSize::I16; }
  else if s.x == p._u32.x { prim.kind = PrimitiveTyKind::Unsigned; prim.node.integer = IntegerSize::I32; }
  else if s.x == p._u64.x { prim.kind = PrimitiveTyKind::Unsigned; prim.node.integer = IntegerSize::I64; }

  else if s.x == p._f32.x { prim.kind = PrimitiveTyKind::Floating; prim.node.floating = FloatingSize::F32; }
  else if s.x == p._f64.x { prim.kind = PrimitiveTyKind::Floating; prim.node.floating = FloatingSize::F64; }

  else  return false;

  return true;
}

fn resolve_path(ctx: *ResolutionContext, path: *Path) {
  var prim: PrimitiveTy;

  if check_if_sid_is_primitive(ctx, path.segments[0].name, &prim) {
    path.binding.kind = BindingKind::PrimitiveType;
    path.binding.node.primitive = prim;
  }
  else if path.num_segments > 1  abort();
  else if path.num_segments == 1 {
    *path = lookup(ctx, path.segments[0]);
  }
}

fn resolve_expr(ctx: *ResolutionContext, expr: *Expr)
fn resolve_item(ctx: *ResolutionContext, item: *Item)

fn resolve_unary(ctx: *ResolutionContext, unary: UnaryData) {
  resolve_expr(ctx, unary.inner);
}

fn resolve_binary(ctx: *ResolutionContext, binary: BinaryData) {
  resolve_expr(ctx, binary.left);
  resolve_expr(ctx, binary.right);
}

fn resolve_call(ctx: *ResolutionContext, call: CallData) {
  resolve_expr(ctx, call.func);

  var i: u32 = 0;
  while i < call.num_args {
    resolve_expr(ctx, call.args[i]);
    i = i + 1;
  }
}

fn resolve_conditional(ctx: *ResolutionContext, cond: ConditionalData) {
  resolve_expr(ctx, cond.condition);
  resolve_expr(ctx, cond.then);
  if (cond.otherwise) {
    resolve_expr(ctx, cond.otherwise);
  }
}

fn resolve_while(ctx: *ResolutionContext, data: WhileData) {
  resolve_expr(ctx, data.condition);
  resolve_expr(ctx, data.body);
}

fn resolve_indexing(ctx: *ResolutionContext, idx: IndexingData) {
  resolve_expr(ctx, idx.array);
  resolve_expr(ctx, idx.index);
}

fn resolve_field(ctx: *ResolutionContext, field: FieldData) {
  resolve_expr(ctx, field.strct);
}

fn resolve_assignment(ctx: *ResolutionContext, assignment: AssignmentData) {
  resolve_expr(ctx, assignment.left);
  resolve_expr(ctx, assignment.right);
}

fn resolve_block(ctx: *ResolutionContext, block: *Block) {

  push_block(ctx);
  var i: u32 = 0;
  while i < block.num_exprs {
    resolve_expr(ctx, block.exprs[i]);
    i = i + 1;
  }
  pop_block(ctx);
}

fn resolve_let(ctx: *ResolutionContext, data: LetData) {
  push_variable(ctx, data.pat.ident);
  resolve_expr(ctx, data.value);
}

fn resolve_expr(ctx: *ResolutionContext, expr: *Expr) {
  if expr.kind == ExprKind::Unary  resolve_unary(ctx, expr.node.unary);
  else if expr.kind == ExprKind::Binary  resolve_binary(ctx, expr.node.binary);
  else if expr.kind == ExprKind::Block  resolve_block(ctx, expr.node.block);
  else if expr.kind == ExprKind::Call  resolve_call(ctx, expr.node.call);
  else if expr.kind == ExprKind::Conditional  resolve_conditional(ctx, expr.node.conditional);
  else if expr.kind == ExprKind::While  resolve_while(ctx, expr.node.whl);
  else if expr.kind == ExprKind::Indexing  resolve_indexing(ctx, expr.node.indexing);
  else if expr.kind == ExprKind::Field  resolve_field(ctx, expr.node.field);
  else if expr.kind == ExprKind::Path  resolve_path(ctx, &expr.node.path);
  else if expr.kind == ExprKind::Assignment  resolve_assignment(ctx, expr.node.assignment);
  else if expr.kind == ExprKind::Let  resolve_let(ctx, expr.node._let);
  else if expr.kind == ExprKind::Return  resolve_expr(ctx, expr.node._return);
  else if expr.kind == ExprKind::Literal {}
  else if expr.kind == ExprKind::ControlFlow  {}
  else abort();
}

fn resolve_function(ctx: *ResolutionContext, item: *Item) {
  var func: FunctionData = item.node.function;
  if func.body {
    push_block(ctx);
    var i: u32 = 0;
    while i < func.header.num_parameters {
      var param: *FunctionParameter = &func.header.parameters[i];
      push_variable(ctx, param.pat.ident);

      i = i + 1;
    }

    resolve_expr(ctx, item.node.function.body);
    pop_block(ctx);
  }
}

fn resolve_variable(ctx: *ResolutionContext, item: *Item) {
  push_block(ctx);
  if item.node.variable.body {
    resolve_expr(ctx, item.node.variable.body);
  }
  pop_block(ctx);
}

fn resolve_module(ctx: *ResolutionContext, module: *Module);

fn resolve_item(ctx: *ResolutionContext, item: *Item) {
  if item.kind == ItemKind::Const || item.kind == ItemKind::Variable  resolve_variable(ctx, item);
  if item.kind == ItemKind::Function  resolve_function(ctx, item);
  if item.kind == ItemKind::Module  resolve_module(ctx, item.node.module);
}

fn resolve_module(ctx: *ResolutionContext, module: *Module) {
  push_module(ctx, module);

  var i: u32 = 0;
  while i < module.num_items {
    resolve_item(ctx, module.items[i]);
    i = i + 1;
  }
  pop_module(ctx);
}

fn resolve(sess: *Session, ast: *Ast) {
  var ctx: ResolutionContext;

  ctx.interner = &sess.interner;
  setup_primitive_ty_sids(ctx.interner, &ctx.primitive_ty_sids);
  ctx.ast = ast;
  ctx.scope_stack = malloc(sizeof(Scope) * 128);
  ctx.stack_top = 0;
  ctx.source_map = &sess.source;
  ctx.root_module = ast.root_module;

  index_use(&ctx, ast.root_module);
  index_module(&ctx, ast.root_module);
  resolve_module(&ctx, ast.root_module);
}
