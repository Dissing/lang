
struct StrMap {
  keys: **char,
  values: *u32,
  size: u64,
  load: u64,
}

fn strmap_create(size: u64) -> *StrMap {
  var map: *StrMap = malloc(sizeof(StrMap));

  map.size = size;
  map.load = 0;
  map.keys = malloc(size*8);
  map.values = malloc(size*4);

  var i: u32 = 0;
  while i < size {
    map.keys[i] = 0;
    map.values[i] = null;
    i = i + 1;
  }

  return map;
}

fn strmap_hash(s: *char) -> u32 {
  var hash: u32 = 5381;
  var c: i32 = *s;
  while c != 0 {
    hash = (hash << 5) + hash + c;
    s = s + 1;
    c = *s;
  }
  if hash != null  return hash;
  else return 1;
}

fn strmap_insert(map: *StrMap, key: *char, value: u32) {
  val h: u32 = strmap_hash(key) % map.size;
  if map.load + 1 >= map.size {
    printf("Hashmap of size %lu is full!\n", map.size);
    exit(-1);
  }
  while true {
    if map.keys[h] != null && !strcmp(map.keys[h], key) {
      map.values[h] = value;
      break;
    } else if map.keys[h] == null {
      map.keys[h] = key;
      map.values[h] = value;
      map.load = map.load + 1;
      break;
    } else {
      h = (h + 1) % map.size;
    }
  }
}

fn strmap_lookup(map: *StrMap, key: *char) -> u32 {
  var h: u32 = strmap_hash(key) % map.size;
  while (true) {
    if map.keys[h] == null  return null;
    if !strcmp(map.keys[h],key)  return map.values[h];
    h = (h + 1) % map.size;
  }
}

fn strmap_destroy(map: *StrMap) {
  free(map.keys);
  free(map.values);
  free(map);
}