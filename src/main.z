import cstd;
import intmap;
import strmap;
import source_map;
import error;
import interning;
import session;
import tokens;
import lexer;
import ast;
import parser;
import resolution;
import typecheck;
import codegen;

extern basename :: (path: *char) -> *char
extern dirname :: (path: *char) -> *char

add_module :: (sess: *Session, target: *CompileTarget, path: Path, parent: *Module) -> *Module;

find_module :: (sess: *Session, target: *CompileTarget, path: Path, parent: *Module) -> *Module {

  i: i32 = 0;
  while i < target.num_modules {
    module: *Module = target.modules[i];
    if module.path.segments[0].name.x == path.segments[0].name.x  return module;
    i = i + 1;
  }

  return add_module(sess, target, path, parent);
}

add_module :: (sess: *Session, target: *CompileTarget, path: Path, parent: *Module) -> *Module {

  source: *SourceFile = source_map_new_file(&sess.source, sess.root_path, get_str(&sess.interner, path.segments[0].name));
  module: *Module = parse(sess, source, path.segments[0].name, parent);

  target.modules[target.num_modules] = module;
  target.num_modules = target.num_modules + 1;

  i: i32 = 0;
  while i < module.num_items {
    item: *Item = &module.items[i];
    if item.kind == ItemKind::Import {
      binding: Binding;
      binding.kind = BindingKind::Module;
      binding.node.module = find_module(sess, target, item.node._import, parent);
      item.node._import.binding = binding;
    }
    i = i + 1;
  }

  resolve_names(sess, module);
  check(sess, module);

  return module;
}

main :: (argc: i32, argv: **char) -> i32 {
  if argc != 3 {
    printf("Usage: compiler INPUT OUTPUT\n");
    abort();
  }

  sess: Session;


  sess.interner = interner_create();
  sess.source = source_map_create();
  root_filename: *char = basename(argv[1]);
  sess.root_path = dirname(argv[1]);

  strtok(root_filename, ".z");

  target: CompileTarget;
  target.modules = malloc(8 * 64);
  target.num_modules = 0;

  root_path: Path;
  root_path.segments = malloc(sizeof(Ident));
  root_path.segments[0].name = intern(&sess.interner, root_filename);
  root_path.num_segments = 1;

  add_module(&sess, &target, root_path, null);

  generate(&sess, &target, argv[2]);

  return 0;
}
