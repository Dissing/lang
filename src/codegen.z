use super::cstd::*;
use super::strmap::*;
use super::interning::*;
use super::source_map::*;
use super::error::*;
use super::ast::*;

struct CodegenContext {
  out: *FILE,
  ident_is_ptr: *StrMap,
  sess: *Session,
  ast: *Ast,
  source: *SourceMap,
  current_module: *Module,
  interner: *Interner,
}

fn generate_expr(ctx: *CodegenContext, expr: *Expr)
fn generate_block(ctx: *CodegenContext, block: *Block)
fn generate_item(ctx: *CodegenContext, item: *Item)

fn type_is_ptr(ty: *AstType) -> u32 {
   if ty.kind == AstTypeKind::Ptr  return 1;
   else return 0;
}

fn generate_prelude(ctx: *CodegenContext) {
  fprintf(ctx.out,"//Prelude\n");
  fprintf(ctx.out,"#include <stdint.h>\n");
  fprintf(ctx.out,"#include <stdbool.h>\n");
  fprintf(ctx.out,"typedef uint8_t u8;\n");
  fprintf(ctx.out,"typedef uint16_t u16;\n");
  fprintf(ctx.out,"typedef uint32_t u32;\n");
  fprintf(ctx.out,"typedef uint64_t u64;\n");
  fprintf(ctx.out,"typedef int8_t i8;\n");
  fprintf(ctx.out,"typedef int16_t i16;\n");
  fprintf(ctx.out,"typedef int32_t i32;\n");
  fprintf(ctx.out,"typedef int64_t i64;\n");
  fprintf(ctx.out,"typedef float f32;\n");
  fprintf(ctx.out,"typedef double f64;\n");
  fprintf(ctx.out,"typedef const char constchar;\n");
  fprintf(ctx.out,"typedef const void constvoid;\n");
}

fn generate_sid(ctx: *CodegenContext, sid: Sid) {
  fprintf(ctx.out, "%s",  get_str(ctx.interner, sid));
}

fn generate_identifier(ctx: *CodegenContext, ident: Ident) {
  generate_sid(ctx, ident.name);
}

fn generate_pattern(ctx: *CodegenContext, pat: Pattern) {
  generate_identifier(ctx, pat.ident);
}

fn mangle_path(ctx: *CodegenContext, path: Path) {
  val item: *Item = path.binding.node.item;
  if (path.binding.kind == BindingKind::Item && item.should_mangle) {
    fprintf(ctx.out, "_ZN");
    var i: u32 = 0;
    while i < path.num_segments {
      var seg: *char = get_str(ctx.interner, path.segments[i].name);
      fprintf(ctx.out, "%lu%s", strlen(seg), seg);
      i = i + 1;
    }
    fprintf(ctx.out, "E");
  } else if path.binding.kind == BindingKind::Variant {
    fprintf(ctx.out, "%s_%s", get_str(ctx.interner, path.segments[path.num_segments-2].name), get_str(ctx.interner, path.segments[path.num_segments-1].name));
  }
  else {
    fprintf(ctx.out, "%s", get_str(ctx.interner, path.segments[path.num_segments-1].name));
  }
}

fn mangle_path_and_ident(ctx: *CodegenContext, path: Path, ident: Ident) {
  fprintf(ctx.out, " _ZN");
  var i: u32 = 0;
  while i < path.num_segments {
    var seg: *char = get_str(ctx.interner, path.segments[i].name);
    fprintf(ctx.out, "%lu%s", strlen(seg), seg);
    i = i + 1;
  }
  var name: *char = get_str(ctx.interner, ident.name);
  fprintf(ctx.out, "%lu%sE", strlen(name), name);
}

fn mangle_function_name(ctx: *CodegenContext, module: *Module, ident: Ident, header: FunctionHeader) {
  mangle_path_and_ident(ctx, module.path, ident);
}

fn generate_type(ctx: *CodegenContext, ty: *AstType) {
  if ty.kind == AstTypeKind::Path {
    mangle_path(ctx, ty.node.path);
  }
  else if ty.kind == AstTypeKind::Ptr {
    generate_type(ctx, ty.node.ptr);
    fprintf(ctx.out, "* ");
  }
  else if ty.kind == AstTypeKind::Void {
    fprintf(ctx.out, "void ");
  }
  else abort();
}

fn generate_char(ctx: *CodegenContext, c: char) {
  if c == '\n'  fprintf(ctx.out, "'\\n'");
  else if c == '\t'  fprintf(ctx.out, "'\\t'");
  else if c == '\r'  fprintf(ctx.out, "'\\r'");
  else if c == '\\'  fprintf(ctx.out, "'\\\\'");
  else if c == '\''  fprintf(ctx.out, "'\\''");
  else fprintf(ctx.out, "'%c'", c);
}

fn generate_literal(ctx: *CodegenContext, lit: Literal) {
  if lit.kind == LiteralKind::Int  fprintf(ctx.out, "%ld", lit.value.integer);
  else if lit.kind == LiteralKind::Float  fprintf(ctx.out, "%f", lit.value.floating);
  else if lit.kind == LiteralKind::Bool  if lit.value.boolean  fprintf(ctx.out, "true") else fprintf(ctx.out, "false");
  else if lit.kind == LiteralKind::Str  {
    fprintf(ctx.out, "\"%s\"",  get_str(ctx.interner, lit.value.str));
  }
  else if lit.kind == LiteralKind::Char  generate_char(ctx, lit.value.ch);
  else abort();
}

fn generate_unary(ctx: *CodegenContext, unary: UnaryData) {
  if unary.op == UnaryOperatorKind::Negation  fprintf(ctx.out, "-");
  else if unary.op == UnaryOperatorKind::Complement  fprintf(ctx.out, "!");
  else if unary.op == UnaryOperatorKind::Refer  fprintf(ctx.out, "&");
  else if unary.op == UnaryOperatorKind::Deref  fprintf(ctx.out, "*");
  else abort();

  generate_expr(ctx, unary.inner);
}

fn generate_binary(ctx: *CodegenContext, binary: BinaryData) {
  fprintf(ctx.out, "(");
  generate_expr(ctx, binary.left);
  if binary.op == BinaryOperatorKind::Addition  fprintf(ctx.out, "+ ");
  else if binary.op == BinaryOperatorKind::Subtraction  fprintf(ctx.out, "- ");
  else if binary.op == BinaryOperatorKind::Product  fprintf(ctx.out, "* ");
  else if binary.op == BinaryOperatorKind::Division  fprintf(ctx.out, "/ ");
  else if binary.op == BinaryOperatorKind::Modulus  fprintf(ctx.out, "%% ");

  else if binary.op == BinaryOperatorKind::Less  fprintf(ctx.out, "< ");
  else if binary.op == BinaryOperatorKind::LessEq  fprintf(ctx.out, "<= ");
  else if binary.op == BinaryOperatorKind::Greater  fprintf(ctx.out, "> ");
  else if binary.op == BinaryOperatorKind::GreaterEq  fprintf(ctx.out, ">= ");
  else if binary.op == BinaryOperatorKind::Equality  fprintf(ctx.out, "== ");
  else if binary.op == BinaryOperatorKind::NotEq  fprintf(ctx.out, "!= ");

  else if binary.op == BinaryOperatorKind::BAnd  fprintf(ctx.out, "& ");
  else if binary.op == BinaryOperatorKind::BOr  fprintf(ctx.out, "| ");
  else if binary.op == BinaryOperatorKind::Xor  fprintf(ctx.out, "^ ");
  else if binary.op == BinaryOperatorKind::LeftShift  fprintf(ctx.out, "<< ");
  else if binary.op == BinaryOperatorKind::RightShift  fprintf(ctx.out, ">> ");

  else if binary.op == BinaryOperatorKind::And  fprintf(ctx.out, "&& ");
  else if binary.op == BinaryOperatorKind::Or  fprintf(ctx.out, "|| ");
  else abort();
  generate_expr(ctx, binary.right);
  fprintf(ctx.out, ")");
}

fn generate_call(ctx: *CodegenContext, call: CallData) {
  generate_expr(ctx, call.func);

  fprintf(ctx.out, "(");
  var i: u32 = 0;
  while i < call.num_args {
    val arg: *Expr = call.args[i];
    generate_expr(ctx, arg);
    if i < call.num_args - 1  fprintf(ctx.out, ",");
    i = i + 1;
  }
  fprintf(ctx.out, ") ");
}

fn generate_conditional(ctx: *CodegenContext, cond: ConditionalData) {
  fprintf(ctx.out, "if (");
  generate_expr(ctx, cond.condition);
  fprintf(ctx.out, ")");
  generate_expr(ctx, cond.then);
  if (cond.otherwise) {
    fprintf(ctx.out, "else ");
    generate_expr(ctx, cond.otherwise);
  }
}

fn generate_while(ctx: *CodegenContext, data: WhileData) {
  fprintf(ctx.out, "while ( ");
  generate_expr(ctx, data.condition);
  fprintf(ctx.out, ")\n");
  generate_expr(ctx, data.body);
}

fn generate_indexing(ctx: *CodegenContext, idx: IndexingData) {
  generate_expr(ctx, idx.array);
  fprintf(ctx.out, "[");
  generate_expr(ctx, idx.index);
  fprintf(ctx.out, "]");
}

fn generate_field(ctx: *CodegenContext, field: FieldData) {
  var strct: *Expr = field.strct;
  generate_expr(ctx, strct);

  var field_name: *char = get_str(ctx.interner, field.ident.name)

  var is_ptr: bool = false;
  var accessor_str: *char;
  if strct.kind == ExprKind::Path {
    var strct_name: *char = get_str(ctx.interner, strct.node.path.segments[0].name)
    is_ptr = strmap_lookup(ctx.ident_is_ptr, strct_name);
  }

  if is_ptr  accessor_str = "->";
  else  accessor_str = ".";
  fprintf(ctx.out, "%s%s", accessor_str, field_name);
}

fn generate_sizeof(ctx: *CodegenContext, expr: *Expr) {
  fprintf(ctx.out, "sizeof(");
  generate_expr(ctx, expr);
  fprintf(ctx.out, ")");
}

fn generate_assignment(ctx: *CodegenContext, assignment: AssignmentData) {
  generate_expr(ctx, assignment.left);
  fprintf(ctx.out, " = ");
  generate_expr(ctx, assignment.right);
  fprintf(ctx.out, ";\n");
}

fn generate_return(ctx: *CodegenContext, expr: *Expr) {
  fprintf(ctx.out, "return ");
  generate_expr(ctx, expr);
  fprintf(ctx.out, ";\n");
}

fn generate_control_flow(ctx: *CodegenContext, is_continue: bool) {
  if is_continue  fprintf(ctx.out, "continue;\n");
  else  fprintf(ctx.out, "break;\n");
}

fn generate_let(ctx: *CodegenContext, data: LetData) {

  generate_type(ctx, data.ast_ty);

  var var_name: *char = get_str(ctx.interner, data.pat.ident.name);

  strmap_insert(ctx.ident_is_ptr, var_name, type_is_ptr(data.ast_ty));
  fprintf(ctx.out, " %s ", var_name);
  if data.value {
    fprintf(ctx.out, "= ");
    generate_expr(ctx, data.value);
  }
  fprintf(ctx.out, ";\n");
}

fn generate_cast(ctx: *CodegenContext, data: CastData) {
  //generate_ty(ctx, data.ty);
  generate_expr(ctx, data.inner);
}

fn generate_expr(ctx: *CodegenContext, expr: *Expr) {
   if expr.kind == ExprKind::Unary  generate_unary(ctx, expr.node.unary);
   else if expr.kind == ExprKind::Binary  generate_binary(ctx, expr.node.binary);
   else if expr.kind == ExprKind::Block  generate_block(ctx, expr.node.block);
   else if expr.kind == ExprKind::Call  generate_call(ctx, expr.node.call);
   else if expr.kind == ExprKind::Conditional  generate_conditional(ctx, expr.node.conditional);
   else if expr.kind == ExprKind::While  generate_while(ctx, expr.node.whl);
   else if expr.kind == ExprKind::Indexing  generate_indexing(ctx, expr.node.indexing);
   else if expr.kind == ExprKind::Field  generate_field(ctx, expr.node.field);
   else if expr.kind == ExprKind::Literal  generate_literal(ctx, expr.node.lit);
   else if expr.kind == ExprKind::Path  mangle_path(ctx, expr.node.path);
   else if expr.kind == ExprKind::Sizeof  generate_sizeof(ctx, expr.node._sizeof);
   else if expr.kind == ExprKind::Assignment generate_assignment(ctx, expr.node.assignment);
   else if expr.kind == ExprKind::ControlFlow  generate_control_flow(ctx, expr.node.control_flow_is_continue);
   else if expr.kind == ExprKind::Let  generate_let(ctx, expr.node._let);
   else if expr.kind == ExprKind::Return  generate_return(ctx, expr.node._return);
   else if expr.kind == ExprKind::Cast  generate_cast(ctx, expr.node._cast);
   else abort();
}

fn generate_block(ctx: *CodegenContext, block: *Block) {
  fprintf(ctx.out, "{\n");
  var i: u32 = 0;

  while i < block.num_exprs {
    var expr: *Expr = block.exprs[i];
    emit_line_directive(ctx.out, ctx.source, expr.span);
    generate_expr(ctx, expr);
    fprintf(ctx.out, ";\n");
    i = i + 1;
  }
  fprintf(ctx.out, "}\n");
}

fn generate_variable(ctx: *CodegenContext, item: *Item) {

  emit_line_directive(ctx.out, ctx.source, item.span);

  generate_type(ctx, item.node.variable.ast_ty);

  var var_name: *char = get_str(ctx.interner, item.ident.name);

  val module: *Module = ctx.current_module;

  strmap_insert(ctx.ident_is_ptr, var_name, type_is_ptr(item.node.variable.ast_ty));
  mangle_path_and_ident(ctx, module.path, item.ident);
  if item.node.variable.body {
    fprintf(ctx.out, "= ");
    generate_expr(ctx, item.node.variable.body);
  }
  fprintf(ctx.out, ";\n");
}

fn generate_function(ctx: *CodegenContext, item: *Item) {

  emit_line_directive(ctx.out, ctx.source, item.span);

  val func: FunctionData = item.node.function;
  val header: FunctionHeader = func.header;
  generate_type(ctx, header.output_ast_ty);

  if item.should_mangle  mangle_function_name(ctx, ctx.current_module, item.ident, header);
  else  fprintf(ctx.out, " %s", get_str(ctx.interner, item.ident.name));
  fprintf(ctx.out, "(");

  var i: u32 = 0;
  while i < header.num_parameters {
    var ty: *AstType = header.parameters[i].ast_ty;
    if ty.kind == AstTypeKind::Variadic {
      fprintf(ctx.out, "...");
      break;
    }

    generate_type(ctx, ty);

    var param_name: *char = get_str(ctx.interner, header.parameters[i].pat.ident.name);
    strmap_insert(ctx.ident_is_ptr, param_name, type_is_ptr(header.parameters[i].ast_ty));
    fprintf(ctx.out, " %s", param_name);
    if i < header.num_parameters - 1  fprintf(ctx.out, ", ");
    i = i + 1;
  }
  fprintf(ctx.out, ") ");
  if func.body  generate_expr(ctx, func.body);
  else  fprintf(ctx.out, ";\n");
}

fn generate_enum(ctx: *CodegenContext, item: *Item) {

  var enum_name: *char = get_str(ctx.interner, item.ident.name);
  val module: *Module = ctx.current_module;

  emit_line_directive(ctx.out, ctx.source, item.span);
  fprintf(ctx.out, "typedef enum");
  mangle_path_and_ident(ctx, module.path, item.ident);
  fprintf(ctx.out, " {\n");
  var i: u32 = 0;

  val data: EnumData = item.node._enum;

  while i < data.num_variants {
    var variant_name: *char = get_str(ctx.interner, data.variants[i].ident.name);
    fprintf(ctx.out, "%s_%s,\n", enum_name, variant_name);
    i = i + 1;
  }
  fprintf(ctx.out, "}");
  mangle_path_and_ident(ctx, module.path, item.ident);
  fprintf(ctx.out, ";\n\n");
}

fn generate_compound(ctx: *CodegenContext, item: *Item) {

  var compound_kind: *char;
  if item.kind == ItemKind::Struct  compound_kind = "struct";
  else  compound_kind = "union";

  val data: CompoundData = item.node.compound;

  val module: *Module = ctx.current_module;

  fprintf(ctx.out, "typedef %s", compound_kind);
  mangle_path_and_ident(ctx, module.path, item.ident);
  mangle_path_and_ident(ctx, module.path, item.ident);
  fprintf(ctx.out, ";\n");

  emit_line_directive(ctx.out, ctx.source, item.span);
  if data.num_fields > 0 {
    fprintf(ctx.out, "typedef %s", compound_kind);
    mangle_path_and_ident(ctx, module.path, item.ident);
    fprintf(ctx.out, " {\n");
    var i: u32 = 0;
    while i < data.num_fields {
      generate_type(ctx, data.fields[i].ast_ty);

      var field_name: *char = get_str(ctx.interner, data.fields[i].ident.name);
      fprintf(ctx.out, " %s;\n", field_name);
      i = i + 1;
    }
    fprintf(ctx.out, "}");
    mangle_path_and_ident(ctx, module.path, item.ident);
    fprintf(ctx.out, ";\n\n");
  }
}

fn generate_mod(ctx: *CodegenContext, module: *Module) {
  var old_module: *Module = ctx.current_module;
  ctx.current_module = module;
  var i: u32 = 0;
  while i < module.num_items {
    generate_item(ctx, module.items[i]);
    i = i + 1;
  }
  ctx.current_module = old_module;
}

fn generate_item(ctx: *CodegenContext, item: *Item) {

  if item.kind == ItemKind::Const || item.kind == ItemKind::Variable  generate_variable(ctx, item);
  else if item.kind == ItemKind::Enum   generate_enum(ctx, item);
  else if item.kind == ItemKind::Function   generate_function(ctx, item);
  else if item.kind == ItemKind::Struct || item.kind == ItemKind::Union  generate_compound(ctx, item);
  else if item.kind == ItemKind::Module  generate_mod(ctx, item.node.module);
  fprintf(ctx.out, "\n");
}

fn generate(sess: *Session, ast: Ast, output_file: *char) {
  var ctx: CodegenContext;

  ctx.out = fopen(output_file, "w");
  ctx.ident_is_ptr = strmap_create(1024);
  ctx.sess = sess;
  ctx.interner = &sess.interner;
  ctx.source = &sess.source;
  ctx.ast = &ast;

  generate_prelude(&ctx);

  generate_mod(&ctx, ast.root_module);
}
