
struct CommonTypes {
  _void: *Ty,
  _bool: *Ty,
  _char: *Ty,
  _i8: *Ty,
  _i16: *Ty,
  _i32: *Ty,
  _i64: *Ty,
  _u8: *Ty,
  _u16: *Ty,
  _u32: *Ty,
  _u64: *Ty,
  _f32: *Ty,
  _f64: *Ty,
}

struct TypeContext {
  ast: *Ast,
  interner: *Interner,
  source_map: *SourceMap,
  common: CommonTypes,
  types_lookup: *IntMap,
  types: *Ty,
  next_type_idx: u32,
  ident_type_lookup: *IntMap,
  node_type_lookup: *IntMap,
}

fn hash_ty(ty: *Ty) -> u64;

fn hash_fn(ty: *Ty) -> u64 {

  var def: FnDef = ty.node.function;
  var h: u64 = hash_ty(def.output);

  var i: u32 = 0;
  while i < def.num_parameters {
    h = h ^ (hash_ty(def.parameters[i]) + 2654435769 + (h << 6) + (h >> 2));
    i = i + 1;
  }
  return h;
}

fn hash_ty(ty: *Ty) -> u64 {

  var h: u64;

  h = ty.kind;

  if ty.kind == TyKind::Signed || ty.kind == TyKind::Unsigned  h = h ^ (ty.node.integer << 4);
  else if ty.kind == TyKind::Floating  h = h ^ (ty.node.floating << 4);
  else if ty.kind == TyKind::Compound  h = h ^ (ty.node.compound.def_id << 4);
  else if ty.kind == TyKind::Enum  h = h ^ (ty.node._enum.def_id << 4);
  else if ty.kind == TyKind::Fn  h = h ^ (hash_fn(ty) << 4);
  else if ty.kind == TyKind::Ptr  h = h ^ (hash_ty(ty.node.ptr) << 4);

  return h;
}

fn intern_ty(ctx: *TypeContext, ty: Ty) -> *Ty {
  val h: u64 = hash_ty(&ty);
  var ty_idx: u32 = intmap_lookup(ctx.types_lookup, h);
  if ty_idx == 0 {
    ty_idx = ctx.next_type_idx;
    ctx.next_type_idx = ctx.next_type_idx + 1;
    intmap_insert(ctx.types_lookup, h, ty_idx);
  }
  return &ctx.types[ty_idx];
}

fn create_base_type(ctx: *TypeContext, kind: TyKind) -> *Ty {
  val ty: Ty;
  ty.kind = kind;
  return intern_ty(ctx, ty);
}

fn create_float_type(ctx: *TypeContext, size: FloatingSize) -> *Ty {
  val ty: Ty;
  ty.kind = TyKind::Floating;
  ty.node.floating = size;
  return intern_ty(ctx, ty);
}

fn create_int_type(ctx: *TypeContext, kind: TyKind, size: IntegerSize) -> *Ty {
  val ty: Ty;
  ty.kind = kind;
  ty.node.integer = size;
  return intern_ty(ctx, ty);
}

fn create_common_types(ctx: *TypeContext) {
  val t: *CommonTypes = &ctx.common;
  t._void = create_base_type(ctx, TyKind::Void);
  t._bool = create_base_type(ctx, TyKind::Bool);
  t._char = create_base_type(ctx, TyKind::Char);

  t._i8 = create_int_type(ctx, TyKind::Signed, IntegerSize::I8);
  t._i16 = create_int_type(ctx, TyKind::Signed, IntegerSize::I16);
  t._i32 = create_int_type(ctx, TyKind::Signed, IntegerSize::I32);
  t._i64 = create_int_type(ctx, TyKind::Signed, IntegerSize::I64);

  t._u8 = create_int_type(ctx, TyKind::Unsigned, IntegerSize::I8);
  t._u16 = create_int_type(ctx, TyKind::Unsigned, IntegerSize::I16);
  t._u32 = create_int_type(ctx, TyKind::Unsigned, IntegerSize::I32);
  t._u64 = create_int_type(ctx, TyKind::Unsigned, IntegerSize::I64);

  t._f32 = create_float_type(ctx, FloatingSize::F32);
  t._f64 = create_float_type(ctx, FloatingSize::F64);
}

fn ast_type_to_ty(ctx: *TypeContext, ast_ty: *AstType) -> *Ty;

fn ast_path_to_ty(ctx: *TypeContext, ast_ty: *AstType) -> *Ty {
  val ty_idx: u32 = intmap_lookup(ctx.ident_type_lookup, ast_ty.node.path.x);
  if ty_idx == 0  abort();
  return &ctx.types[ty_idx];
}

fn ast_ptr_to_ty(ctx: *TypeContext, ast_ty: *AstType) -> *Ty {
  val ty: Ty;
  ty.kind = TyKind::Ptr;
  ty.node.ptr = ast_type_to_ty(ctx, ast_ty.node.ptr);
  return intern_ty(ctx, ty);
}

fn ast_type_to_ty(ctx: *TypeContext, ast_ty: *AstType) -> *Ty {
  if ast_ty.kind == AstTypeKind::Void  return ctx.common._void;
  else if ast_ty.kind == AstTypeKind::Path  return ast_path_to_ty(ctx, ast_ty);
  else if ast_ty.kind == AstTypeKind::Ptr  return ast_ptr_to_ty(ctx, ast_ty);
  else abort();
}

fn type_of_node(ctx: *TypeContext, node: NodeId) -> *Ty {
  var def: u64 = node.def;
  var k: u64 = (def << 32) | node.local;
  val ty_idx: u32 = intmap_lookup(ctx.ident_type_lookup, k);
  if ty_idx == 0  abort();
  return &ctx.types[ty_idx];
}

fn check_expr(ctx: *TypeContext, expr: *Expr) -> *Ty;
fn check_block(ctx: *TypeContext, block: *Block);
fn check_stmt(ctx: *TypeContext, stmt: *Stmt);
fn check_item(ctx: *TypeContext, item: *Item);
fn check_mod(ctx: *TypeContext, module: *Mod);

fn check_unary(ctx: *TypeContext, expr: *Expr) -> *Ty {
  var inner: *Ty = check_expr(ctx, expr.node.unary.inner);
  return inner;
}

fn check_binary(ctx: *TypeContext, expr: *Expr) -> *Ty {
  var left: *Ty = check_expr(ctx, expr.node.binary.left);
  var right: *Ty = check_expr(ctx, expr.node.binary.right);
  if left != right  emit_error(ctx.source_map, expr.span, "Arguments of binary op must be compatible");

  return left;
}

fn check_block_expr(ctx: *TypeContext, expr: *Expr) -> *Ty {
  return ctx.common._void;
}

fn check_call(ctx: *TypeContext, expr: *Expr) -> *Ty {
  var call: CallData = expr.node.call;
  val fn_ty: *Ty = check_expr(ctx, call.func);
  if fn_ty.kind != TyKind::Fn  emit_error(ctx.source_map, expr.span, "Tried to call non-function");

  val fn_def: *FnDef = &fn_ty.node.function;

  var i: i32 = 0;
  while i < call.num_args {
    val arg_ty: *Ty = check_expr(ctx, call.args[i]);
    if arg_ty != fn_def.parameters[i]  emit_error(ctx.source_map, expr.span, "Function parameter type mismatch");
    i = i + 1;
  }
  return fn_def.output;
}

fn check_conditional(ctx: *TypeContext, expr: *Expr) -> *Ty {
  var data: ConditionalData = expr.node.conditional;
  var condition: *Expr = data.condition;
  val cond_ty: *Ty = check_expr(ctx, condition);
  if cond_ty.kind != TyKind::Bool  emit_error(ctx.source_map, condition.span, "Condition must be of type bool");

  check_expr(ctx, data.then);
  if data.otherwise {
     check_expr(ctx, data.otherwise);
  }
  return ctx.common._void;
}

fn check_while(ctx: *TypeContext, expr: *Expr) -> *Ty {
  var data: WhileData = expr.node.whl;
  var condition: *Expr = data.condition;
  val cond_ty: *Ty = check_expr(ctx, condition);
  if cond_ty.kind != TyKind::Bool  emit_error(ctx.source_map, condition.span, "Condition must be of type bool");
  check_expr(ctx, data.body);
  return ctx.common._void;
}

fn check_indexing(ctx: *TypeContext, expr: *Expr) -> *Ty {
  val data: IndexingData = expr.node.indexing;
  val array_ty: *Ty = check_expr(ctx, data.array);
  if array_ty.kind != TyKind::Ptr   emit_error(ctx.source_map, expr.span, "Cannot index into non-ptr type");
  val index_ty: *Ty = check_expr(ctx, data.index);
  if !(index_ty.kind == TyKind::Signed || index_ty.kind == TyKind::Unsigned) {
     emit_error(ctx.source_map, expr.span, "Cannot index into non-ptr type");
  }
  return array_ty.node.ptr;
}

fn check_field(ctx: *TypeContext, expr: *Expr) -> *Ty {
  val data: FieldData = expr.node.field;
  var compound_ty: *Ty = check_expr(ctx, data.strct);

  var ptr_inner: *Ty = compound_ty.node.ptr;
  if compound_ty.kind == TyKind::Ptr && ptr_inner.kind == TyKind::Compound  compound_ty = compound_ty.node.ptr;

  if compound_ty.kind != TyKind::Compound   emit_error(ctx.source_map, expr.span, "Cannot access field of non-compound type");

  val compound: CompoundDef = compound_ty.node.compound;

  var i: u32 = 0;
  while i < compound.num_fields {
    if compound.fields[i].ident.name.x == data.ident.name.x {
      return compound.fields[i].ty;
    }
  }
  emit_error(ctx.source_map, expr.span, "Compound type has no such field");
  return null;
}

fn check_path(ctx: *TypeContext, path: *Path) -> *Ty {
  return type_of_node(ctx, path.res.node.def);
}

fn check_expr(ctx: *TypeContext, expr: *Expr) -> *Ty {
  if expr.kind == ExprKind::Unary  return check_unary(ctx, expr);
  else if expr.kind == ExprKind::Binary  return check_binary(ctx, expr);
  else if expr.kind == ExprKind::Block  return check_block_expr(ctx, expr);
  else if expr.kind == ExprKind::Call  return check_call(ctx, expr);
  else if expr.kind == ExprKind::Conditional  return check_conditional(ctx, expr);
  else if expr.kind == ExprKind::While  return check_while(ctx, expr);
  else if expr.kind == ExprKind::Indexing  return check_indexing(ctx, expr);
  else if expr.kind == ExprKind::Field  return check_field(ctx, expr);
  else if expr.kind == ExprKind::Path  return check_path(ctx, &expr.node.path);
  else abort();
}

fn check_assignment(ctx: *TypeContext, assignment: AssignmentData) {
  check_expr(ctx, assignment.left);
  check_expr(ctx, assignment.right);
}

fn check_return(ctx: *TypeContext, expr: *Expr) {
  check_expr(ctx, expr);
}

fn check_stmt(ctx: *TypeContext, stmt: *Stmt) {
  if stmt.kind == StmtKind::Assignment  check_assignment(ctx, stmt.node.assignment);
  else if stmt.kind == StmtKind::Break  {}
  else if stmt.kind == StmtKind::Continue  {}
  else if stmt.kind == StmtKind::Expr  check_expr(ctx, stmt.node.expr);
  else if stmt.kind == StmtKind::Item  check_item(ctx, ast_get_item(ctx.ast, stmt.node.item));
  else if stmt.kind == StmtKind::Return  check_return(ctx, stmt.node._return);
  else abort();
}

fn check_variable(ctx: *TypeContext, item: *Item) {
  var decl_ty: *Ty = ast_type_to_ty(ctx, item.node.variable.ty);

  var body: *Body = ast_get_body(ctx.ast, item.node.variable.body);
  if body > 0 {
    var expr_ty: *Ty = check_expr(ctx, body.value);
    if decl_ty != expr_ty  emit_error(ctx.source_map, item.span, "Variable type declaration does not match expression type");
  }
}

fn check_function(ctx: *TypeContext, item: *Item) {

  var body: *Body = ast_get_body(ctx.ast, item.node.variable.body);
  if body > 0 {
    check_expr(ctx, body.value);
  }
}

fn check_item(ctx: *TypeContext, item: *Item) {
  if item.kind == ItemKind::Enum  {}
  else if item.kind == ItemKind::Struct || item.kind == ItemKind::Union  {}
  else if item.kind == ItemKind::Mod  check_mod(ctx, &item.node.module);
  else if item.kind == ItemKind::Const || item.kind == ItemKind::Variable  check_variable(ctx, item);
  else if item.kind == ItemKind::Function  check_function(ctx, item);
}

fn check_mod(ctx: *TypeContext, module: *Mod) {
  var i: u32 = 0;
  while i < module.num_items {
    var item: *Item = ast_get_item(ctx.ast, module.items[i]);
    check_item(ctx, item);
    i = i + 1;
  }
}

fn check(sess: *Session, ast: *Ast) {
  var ctx: TypeContext;

  ctx.interner = &sess.interner;
  ctx.source_map = &sess.source;
  ctx.ast = ast;

  check_mod(&ctx, &ast.root_module);
}
