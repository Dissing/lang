
struct AstType {}
struct Expr {}
struct Block {}

struct NodeId {
  def: u32,
  local: u32,
}

struct Ident {
  name: Sid,
}

enum ResKind {
  Definition,
  Primitive,
}

union ResNode {
  def: NodeId,
  prim: PrimitiveTy,
}

struct Res {
  kind: ResKind,
  node: ResNode,
}

struct Path {
  segments: *Ident,
  num_segments: u32,
  res: Res,
  span: Span,
}

struct Mod {
  span: Span,
  items: *NodeId,
  num_items: u32,
}

enum AstTypeKind {
  Void,
  Ptr,
  Path,
  Variadic,
}

struct GenericParam {
  id: NodeId,
  ident: Ident,
}

struct Generics {
  parameters: *GenericParam,
  num_parameters: u32,
  span: Span,
}

union AstTypeKindNode {
  path: Sid,
  ptr: *AstType,
}

struct AstType {
  id: NodeId,
  kind: AstTypeKind,
  node: AstTypeKindNode,
}

enum LiteralKind {
  Int,
  Float,
  Bool,
  Char,
  Str,
}

union LiteralValue {
  floating: f64,
  integer: u64,
  boolean: bool,
  ch: char,
  str: Sid,
}

struct Literal {
  kind: LiteralKind,
  value: LiteralValue,
}


enum UnaryOperatorKind {
  // "*" operator for dereferencing pointers
  Deref,
  // "&" operator for taking the address of a place
  Refer,
  // "-" operator for numerical negation
  Negation,
  // "!" for logical not
  Complement,
}

enum BinaryOperatorKind {
  Invalid, //Temporary until we get option types
  //Aritmetic operators
  Addition,
  Subtraction,
  Product,
  Division,
  Modulus,

  //Comperative operators
  Less,
  LessEq,
  Greater,
  GreaterEq,
  Equality,
  NotEq,

  //Bitwise operators
  BAnd,
  BOr,
  Xor,
  LeftShift,
  RightShift,

  //Logical operators
  And,
  Or,
}

struct BinaryData {
  op: BinaryOperatorKind,
  left: *Expr,
  right: *Expr,
}

struct CallData {
  func: *Expr,
  args: **Expr,
  num_args: u32,
}

struct ConditionalData {
  condition: *Expr,
  then: *Expr,
  otherwise: *Expr,
}

struct WhileData {
  condition: *Expr,
  body: *Expr,
}

struct IndexingData {
  array: *Expr,
  index: *Expr,
}

struct FieldData {
  strct: *Expr,
  ident: Ident,
}

struct UnaryData {
  op: UnaryOperatorKind,
  inner: *Expr,
}

enum ExprKind {
  Binary,
  Block,
  Call,
  Conditional,
  Field,
  Indexing,
  Path,
  Literal,
  Unary,
  While,
}

union ExprKindNode {
  binary: BinaryData,
  block: *Block,
  call: CallData,
  conditional: ConditionalData,
  field: FieldData,
  indexing: IndexingData,
  path: Path,
  lit: Literal,
  unary: UnaryData,
  whl: WhileData,
}

struct Expr {
  id: NodeId,
  span: Span,
  kind: ExprKind,
  node: ExprKindNode,
}

struct AssignmentData {
  left: *Expr,
  right: *Expr,
}

enum StmtKind {
  Assignment,
  Item,
  Expr,
  Return,
  Break,
  Continue,
  Defer,
  Empty,
}

union StmtKindNode {
  assignment: AssignmentData,
  item: NodeId,
  expr: *Expr,
  _return: *Expr,
  _defer: *Expr,
}

struct Stmt {
  kind: StmtKind,
  node: StmtKindNode,
  span: Span,
  id: NodeId,
}

struct Block {
  stmts: **Stmt,
  num_stmts: u32,
  id: NodeId,
  span: Span,
}

struct Body {
  value: *Expr,
}

enum VisibilityKind {
  Public,
  Private,
}

struct Visibility {
  kind: VisibilityKind,
}

struct CompoundField {
  ident: Ident,
  id: NodeId,
  ty: *AstType,
}

struct CompoundData {
  fields: *CompoundField,
  num_fields: u32,
  generics: Generics,
}

struct EnumVariant {
  ident: Ident,
  id: NodeId,
}

struct EnumData {
  variants: *EnumVariant,
  num_variants: u32,
}

struct FunctionParameter {
  ident: Ident,
  id: NodeId,
  ty: *AstType,
}


struct FunctionHeader {
  parameters: *FunctionParameter,
  num_parameters: u32,
  output: *AstType,
  generics: Generics,
}

struct FunctionData {
  header: FunctionHeader,
  body: NodeId,
}

struct UseData {
  path: Path,
}

struct VariableData {
  ty: *AstType,
  mutable: bool,
  body: NodeId,
}

enum ItemKind {
  Const,
  Enum,
  Function,
  Mod,
  Struct,
  Union,
  Use,
  Variable,
}

union ItemKindNode {
  compound: CompoundData,
  _enum: EnumData,
  variable: VariableData,
  function: FunctionData,
  module: Mod,
  _use: UseData,
}

struct Item {
  ident: Ident,
  id: NodeId,
  kind: ItemKind,
  node: ItemKindNode,
  vis: Visibility,
  span: Span,
}

struct Ast {
  body_map: *IntMap,
  bodies: *Body,
  num_bodies: u32,

  items: *Item,
  num_items: u32,

  next_local: *u32,

  root_module: Mod,
}

fn ast_create_node_id(ast: *Ast, def: NodeId) -> NodeId {
  val id: NodeId;
  id.def = def.def;
  ast.next_local[def.def] = ast.next_local[def.def] + 1;
  id.local = ast.next_local[def.def];
  return id;
}

fn ast_create_expr(ast: *Ast, def: NodeId, kind: ExprKind) -> *Expr {
  var expr: *Expr = malloc(sizeof(Expr));
  expr.kind = kind;
  expr.id = ast_create_node_id(ast, def);

  return expr;
}

fn ast_create_stmt(ast: *Ast, def: NodeId) -> *Stmt {
  var stmt: *Stmt = malloc(sizeof(Stmt));
  stmt.id = ast_create_node_id(ast, def);

  return stmt;
}

fn ast_create_body(ast: *Ast, expr: *Expr) -> NodeId {

  val idx: u32 = ast.num_bodies;
  var body: *Body = &ast.bodies[idx];
  ast.num_bodies = ast.num_bodies + 1;

  body.value = expr;

  val def: u64 = expr.id.def;
  val local: u64 = expr.id.local;
  val key: u64 = (def << 32) | local;
  intmap_insert(ast.body_map, key, idx);

  return expr.id;
}

fn ast_get_body(ast: *Ast, id: NodeId) -> *Body {
  val def: u64 = id.def;
  val key: u64 = (def << 32) | (id.local);
  val idx: u32 = intmap_lookup(ast.body_map, key);
  return &ast.bodies[idx];
}

fn ast_create_item(ast: *Ast) -> *Item {

  val idx: u32 = ast.num_items;
  var item: *Item = &ast.items[idx];
  ast.num_items = ast.num_items + 1;

  item.id.def = idx;
  item.id.local = 0;

  return item;
}

fn ast_get_item(ast: *Ast, id: NodeId) -> *Item {
  return &ast.items[id.def];
}
