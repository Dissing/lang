use super::cstd::*;
use super::intmap::IntMap;
use super::source_map::*;
use super::interning::Sid;
use super::error::*;

AstType :: struct {}
Expr :: struct {}
Block :: struct {}
Item :: struct {}

Ident :: struct {
  name: Sid,
  span: Span,
}

IntegerSize :: enum {
  I8,
  I16,
  I32,
  I64,
  Int_Arch,
  Int_Unspecified,
}

integer_size :: (size: IntegerSize) -> u32 {
  if size == IntegerSize::I8  return 8;
  else if size == IntegerSize::I16  return 16;
  else if size == IntegerSize::I32  return 32;
  else if size == IntegerSize::I64  return 64;
  else abort();
}

FloatingSize :: enum {
  F32,
  F64,
  Float_Unspecified,
}

floating_size :: (size: FloatingSize) -> u32 {
  if size == FloatingSize::F32  return 32;
  else if size == FloatingSize::F64  return 64;
  else abort();
}

PrimitiveTyKind :: enum {
  Void,
  ConstVoid,
  Signed,
  Unsigned,
  Floating,
  Bool,
  Char,
  ConstChar,
}

PrimitiveTyNode :: union {
  integer: IntegerSize,
  floating: FloatingSize,
}

PrimitiveTy :: struct {
  node: PrimitiveTyNode,
  kind: PrimitiveTyKind,
}

BindingKind :: enum {
  Item,
  Variable,
  Local,
  Parameter,
  PrimitiveType,
  Variant,
}

Item :: struct {}
EnumVariant :: struct {}
FunctionParameter :: struct {}
LetData :: struct {}
LocalData :: struct {}
PrimitiveTy :: struct {}

BindingNode :: union {
  item: *Item,
  variable: *LetData,
  local: *LocalData,
  parameter: *FunctionParameter,
  primitive: PrimitiveTy,
  variant: *EnumVariant,
}

Binding :: struct {
  kind: BindingKind,
  node: BindingNode,
}

Path :: struct {
  segments: *Ident,
  num_segments: u32,
  binding: Binding,
  span: Span,
}

Ty :: struct {};

FieldDef :: struct {
  name: Sid,
  ty: *Ty,
}

CompoundDef :: struct {
  path: Path,
  fields: *FieldDef,
  num_fields: u32,
}

EnumDef :: struct {
  path: Path,
  variants: *Sid,
  num_variants: u32,
}

FnDef :: struct {
  parameters: **Ty,
  num_parameters: u32,
  output: *Ty,
}

TyKind :: enum {
  Void,
  ConstVoid,
  Variadic,
  Bool,
  Char,
  ConstChar,
  Signed,
  Unsigned,
  Floating,
  Ptr,
  Fn,
  Enum,
  Struct,
  Union,
}

TyKindNode :: union {
  integer: IntegerSize,
  floating: FloatingSize,
  ptr: *Ty,
  compound: CompoundDef,
  _enum: EnumDef,
  function: FnDef,
}

Ty :: struct {
  kind: TyKind,
  node: TyKindNode,
}

Pattern :: struct {
  ident: Ident,
  span: Span,
}

Item :: struct {}

IndexEntry :: struct {
  path: Path,
}

Module :: struct {
  span: Span,
  items: **Item,
  num_items: u32,
  index_lookup: *IntMap,
  index: *IndexEntry,
  num_indices: u32,
  path: Path,
  parent: *Module,
}

AstTypeKind :: enum {
  Void,
  Ptr,
  Path,
  Variadic,
}

GenericParam :: struct {
  ident: Ident,
}

Generics :: struct {
  parameters: *GenericParam,
  num_parameters: u32,
  span: Span,
}

AstTypeKindNode :: union {
  path: Path,
  ptr: *AstType,
}

AstType :: struct {
  kind: AstTypeKind,
  node: AstTypeKindNode,
  ty: *Ty,
}

LiteralKind :: enum {
  Int,
  Float,
  Bool,
  Char,
  Str,
}

LiteralValue :: union {
  floating: f64,
  integer: u64,
  boolean: bool,
  ch: char,
  str: Sid,
}

Literal :: struct {
  kind: LiteralKind,
  value: LiteralValue,
}


UnaryOperatorKind :: enum {
  // "*" operator for dereferencing pointers
  Deref,
  // "&" operator for taking the address of a place
  Refer,
  // "-" operator for numerical negation
  Negation,
  // "!" for logical not
  Complement,
}

BinaryOperatorKind :: enum {
  Invalid, //Temporary until we get option types
  //Aritmetic operators
  Addition,
  Subtraction,
  Product,
  Division,
  Modulus,

  //Comperative operators
  Less,
  LessEq,
  Greater,
  GreaterEq,
  Equality,
  NotEq,

  //Bitwise operators
  BAnd,
  BOr,
  Xor,
  LeftShift,
  RightShift,

  //Logical operators
  And,
  Or,
}

BinaryData :: struct {
  op: BinaryOperatorKind,
  left: *Expr,
  right: *Expr,
}

CallData :: struct {
  func: *Expr,
  args: **Expr,
  num_args: u32,
}

CastData :: struct {
  inner: *Expr,
  ast_ty: *AstType,
  ty: *Ty,
}

ConditionalData :: struct {
  condition: *Expr,
  then: *Expr,
  otherwise: *Expr,
}

WhileData :: struct {
  condition: *Expr,
  body: *Expr,
}

IndexingData :: struct {
  array: *Expr,
  index: *Expr,
}

FieldData :: struct {
  strct: *Expr,
  ident: Ident,
}

UnaryData :: struct {
  op: UnaryOperatorKind,
  inner: *Expr,
}

AssignmentData :: struct {
  left: *Expr,
  right: *Expr,
}

LetData :: struct {
  pat: Pattern,
  value: *Expr,
  ast_ty: *AstType,
  ty: *Ty,
}

LocalData :: struct {
  pat: Pattern,
  value: *Expr,
  ast_ty: *AstType,
  ty: *Ty,
}

ExprKind :: enum {
  Binary,
  Block,
  Call,
  Cast,
  Conditional,
  Field,
  Indexing,
  Path,
  Literal,
  Sizeof,
  Unary,
  While,
  Assignment,
  Let,
  Local,
  Return,
  ControlFlow,
  Defer,
  Empty,
}

ExprKindNode :: union {
  binary: BinaryData,
  block: *Block,
  call: CallData,
  _cast: CastData,
  conditional: ConditionalData,
  control_flow_is_continue: bool,
  field: FieldData,
  indexing: IndexingData,
  path: Path,
  lit: Literal,
  _sizeof: *Expr,
  unary: UnaryData,
  whl: WhileData,
  assignment: AssignmentData,
  _return: *Expr,
  _let: LetData,
  local: LocalData,
}

Expr :: struct {
  span: Span,
  kind: ExprKind,
  node: ExprKindNode,
  ty: *Ty,
}

Block :: struct {
  exprs: **Expr,
  num_exprs: u32,
  span: Span,
}

VisibilityKind :: enum {
  Public,
  Private,
}

Visibility :: struct {
  kind: VisibilityKind,
}

CompoundField :: struct {
  ident: Ident,
  ast_ty: *AstType,
}

CompoundData :: struct {
  fields: *CompoundField,
  num_fields: u32,
  generics: Generics,
  ty: *Ty,
}

EnumVariant :: struct {
  ident: Ident,
  _enum: *Item,
}

EnumData :: struct {
  variants: *EnumVariant,
  num_variants: u32,
  ty: *Ty,
}

FunctionParameter :: struct {
  pat: Pattern,
  ast_ty: *AstType,
  ty: *Ty,
}


FunctionHeader :: struct {
  parameters: *FunctionParameter,
  num_parameters: u32,
  output_ast_ty: *AstType,
  generics: Generics,
  ty: *Ty,
}

FunctionData :: struct {
  header: FunctionHeader,
  body: *Expr,
}


VariableData :: struct {
  ast_ty: *AstType,
  ty: *Ty,
  mutable: bool,
  body: *Expr,
}

ItemKindNode :: union {
  compound: CompoundData,
  _enum: EnumData,
  variable: VariableData,
  function: FunctionData,
  module: *Module,
  _use: Path,
}

ItemKind :: enum {
  Const,
  Enum,
  Function,
  Module,
  Struct,
  Union,
  Use,
  Variable,
}

Item :: struct {
  ident: Ident,
  kind: ItemKind,
  node: ItemKindNode,
  vis: Visibility,
  span: Span,
  should_mangle: bool,
}

Ast :: struct {
  items: *Item,
  num_items: u32,

  root_module: *Module,
}

ast_create_expr :: (ast: *Ast, kind: ExprKind) -> *Expr {
  var expr: *Expr = malloc(sizeof(Expr));
  expr.kind = kind;

  return expr;
}

ast_create_item :: (ast: *Ast) -> *Item {

  var item: *Item = &ast.items[ast.num_items];
  ast.num_items = ast.num_items + 1;

  return item;
}
