
struct Span {
  from: u32,
  to: u32,
}

struct SourceFile {
  name: *char,
  content: *char,
  length: u32,
  start: u32,
  end: u32,
  lines: *u32,
  num_lines: u32,
}

struct SourceMap {
  files: *SourceFile,
  num_files: u32,
  file_starts: *u32,
}

fn source_snippet(m: *SourceMap, span: Span) {
  var i: u32 = 0;
  var file: *SourceFile = 0;
  while i < m.num_files {
    if m.file_starts[i] >= span.from {
      file = &m.files[i];
      break;
    }
    i = i + 1;
  }

  if !file  abort();

  var line_first: u32 = 0;
  var line_last: u32 = 0;
  i = 0;
  while i < file.num_lines {
    if file.lines[i] < span.from {
      line_first = i;
    }
    else  break;
    i = i + 1;
  }
  i = i - 1;
  while i < file.num_lines {
    if file.lines[i] <= span.to {
      line_last = i;
    }
    else  break;
    i = i + 1;
  }

  printf("%s:%u\n", file.name, line_first);

  var buffer: *char = malloc(1024);
  i = line_first;
  while i <= line_last {
    val line_start: u32 = file.lines[i];
    val line_end: u32 = file.lines[i + 1];
    var length: u32 = line_end - line_start;

    memcpy(buffer, &file.content[line_start], length);
    buffer[length+1] = 0;
    printf("%s\n", buffer);
    i = i + 1;
  }

}

fn emit_error(m: *SourceMap, span: Span, msg: *char) {
  printf("error: %s\n", msg);
  source_snippet(m, span);
  abort();
}
